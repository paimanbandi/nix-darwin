local M = {}
local prompts = require("plugins.markdown-ai-prompts")
local detector = require("plugins.markdown-ai-detector")
local providers = require("plugins.markdown-ai-providers")

-- Validate Mermaid syntax
M.validate_mermaid = function(content)
  local styled_nodes = {}
  for node_id in content:gmatch("style%s+(%w+)%s+fill") do
    styled_nodes[node_id] = true
  end

  local has_issues = false
  for node_id, _ in pairs(styled_nodes) do
    if not content:match(node_id .. "%s*%[") and
        not content:match(node_id .. "%s*%(") and
        not content:match(node_id .. "%s*{") then
      print("Warning: Styled node '" .. node_id .. "' not found")
      has_issues = true
    end
  end

  return not has_issues
end

-- Call AI provider with automatic fallback
M.call_ai = function(prompt, output_file, title)
  vim.notify("Generating diagram (10-30 seconds)...", vim.log.levels.INFO)

  providers.call_provider(prompt, {
    on_success = function(response, provider_name)
      -- Clean up response - extract mermaid block if surrounded by text
      local mermaid_block = response:match("```mermaid(.-)```")

      if mermaid_block then
        -- Rebuild proper mermaid block
        response = "```mermaid" .. mermaid_block .. "```"
      elseif not response:match("```mermaid") then
        -- Try alternative patterns
        mermaid_block = response:match("```(.-)```")
        if mermaid_block and not mermaid_block:match("^mermaid") then
          response = "```mermaid" .. mermaid_block .. "```"
        else
          vim.notify("Invalid response: No mermaid blocks found", vim.log.levels.ERROR)

          -- Save debug output
          local debug_file = output_file:gsub("%.md$", "_debug.txt")
          local file = io.open(debug_file, "w")
          if file then
            file:write("=== INVALID RESPONSE from " .. provider_name .. " ===\n\n")
            file:write("Expected: ```mermaid ... ```\n")
            file:write("Got:\n\n")
            file:write(response)
            file:close()
            vim.notify("Debug output saved to: " .. debug_file, vim.log.levels.INFO)
            vim.notify("Try regenerating with <leader>mr or use different provider", vim.log.levels.INFO)
          end
          return
        end
      end

      -- Validate mermaid syntax
      if not M.validate_mermaid(response) then
        vim.notify("Warning: Some style definitions may not match nodes", vim.log.levels.WARN)
      end

      -- Create markdown file with metadata
      local md_content = string.format([[# %s

Generated Date: %s
Generated by: %s

%s
]], title, os.date("%Y-%m-%d %H:%M:%S"), providers.providers[provider_name].name, response)

      local file = io.open(output_file, "w")
      if file then
        file:write(md_content)
        file:close()

        vim.notify("Diagram generated successfully with " .. providers.providers[provider_name].name,
          vim.log.levels.INFO)

        vim.schedule(function()
          vim.cmd("edit " .. vim.fn.fnameescape(output_file))
          vim.defer_fn(function()
            vim.cmd("MarkdownPreview")
            vim.notify("Preview opened in browser", vim.log.levels.INFO)
          end, 200)
        end)
      else
        vim.notify("Failed to write output file", vim.log.levels.ERROR)
      end
    end,

    on_error = function(error_msg)
      vim.notify("Generation failed: " .. error_msg, vim.log.levels.ERROR)
      vim.notify("Check provider status with <leader>mi", vim.log.levels.INFO)
    end
  })
end

-- Generate with auto-detection of diagram type
M.generate_auto = function(complexity)
  local filetype = vim.bo.filetype
  local filename = vim.fn.expand('%:t:r')
  local dir = vim.fn.expand('%:p:h')

  local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
  local code_content = table.concat(lines, "\n")

  if #lines > 500 then
    vim.notify("Large file (" .. #lines .. " lines). Generation may take 30-60 seconds", vim.log.levels.WARN)
  end

  -- Auto-detect best diagram type
  vim.notify("Analyzing code...", vim.log.levels.INFO)
  local analysis = detector.detect_diagram_type(code_content, filetype)
  local recommended, scores = detector.recommend_diagram_type(analysis)

  vim.notify("Recommended diagram type: " .. recommended, vim.log.levels.INFO)

  -- Build prompt based on recommendation
  local prompt
  if recommended == "flowchart" then
    prompt = prompts.build_flowchart_prompt(filetype, code_content, complexity or "moderate")
  elseif recommended == "sequence" then
    prompt = prompts.build_sequence_prompt(filetype, code_content)
  elseif recommended == "class_diagram" then
    prompt = prompts.build_class_diagram_prompt(filetype, code_content)
  elseif recommended == "state_diagram" then
    prompt = prompts.build_state_diagram_prompt(filetype, code_content)
  else
    prompt = prompts.build_flowchart_prompt(filetype, code_content, complexity or "moderate")
  end

  local output_file = dir .. "/" .. filename .. "_" .. recommended .. ".md"
  local title = filename .. " - " .. recommended:gsub("_", " "):gsub("^%l", string.upper)

  M.call_ai(prompt, output_file, title)
end

-- Generate with manual diagram type selection
M.generate_manual = function()
  local filetype = vim.bo.filetype
  local filename = vim.fn.expand('%:t:r')
  local dir = vim.fn.expand('%:p:h')

  local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
  local code_content = table.concat(lines, "\n")

  if #lines > 500 then
    vim.notify("Large file (" .. #lines .. " lines). Generation may take longer", vim.log.levels.WARN)
  end

  -- Show diagram type selection menu
  local choice = vim.fn.confirm(
    "Select diagram type:",
    "&Flowchart (Process Flow)\n" ..
    "&Sequence (Time-based Interactions)\n" ..
    "&Class (Object Structure)\n" ..
    "S&tate (State Transitions)\n" ..
    "&ER (Database Schema)\n" ..
    "&Cancel",
    1
  )

  if choice == 6 or choice == 0 then
    return
  end

  local diagram_type
  local prompt

  if choice == 1 then
    diagram_type = "flowchart"

    -- Ask for complexity level
    local complexity_choice = vim.fn.confirm(
      "Select complexity:",
      "&Simple (30 nodes)\n&Moderate (50 nodes)\n&Detailed (80 nodes)",
      2
    )

    local complexity = "moderate"
    if complexity_choice == 1 then
      complexity = "simple"
    elseif complexity_choice == 3 then
      complexity = "detailed"
    end

    prompt = prompts.build_flowchart_prompt(filetype, code_content, complexity)
  elseif choice == 2 then
    diagram_type = "sequence"
    prompt = prompts.build_sequence_prompt(filetype, code_content)
  elseif choice == 3 then
    diagram_type = "class_diagram"
    prompt = prompts.build_class_diagram_prompt(filetype, code_content)
  elseif choice == 4 then
    diagram_type = "state_diagram"
    prompt = prompts.build_state_diagram_prompt(filetype, code_content)
  elseif choice == 5 then
    diagram_type = "er_diagram"
    prompt = prompts.build_er_diagram_prompt(filetype, code_content)
  end

  local output_file = dir .. "/" .. filename .. "_" .. diagram_type .. ".md"
  local title = filename .. " - " .. diagram_type:gsub("_", " "):gsub("^%l", string.upper)

  vim.notify("Generating " .. diagram_type:gsub("_", " ") .. "...", vim.log.levels.INFO)

  M.call_ai(prompt, output_file, title)
end

-- Generate from visual selection
M.generate_from_selection = function()
  local start_pos = vim.fn.getpos("'<")
  local end_pos = vim.fn.getpos("'>")

  if start_pos[2] == 0 or end_pos[2] == 0 then
    vim.notify("No selection found. Use visual mode first", vim.log.levels.WARN)
    return
  end

  local lines = vim.api.nvim_buf_get_lines(0, start_pos[2] - 1, end_pos[2], false)
  local code_content = table.concat(lines, "\n")

  if code_content == "" or code_content:match("^%s*$") then
    vim.notify("Empty selection", vim.log.levels.WARN)
    return
  end

  local filetype = vim.bo.filetype
  local dir = vim.fn.expand('%:p:h')
  local output_file = dir .. "/selection_diagram.md"

  vim.notify("Generating diagram from selection (" .. #lines .. " lines)...", vim.log.levels.INFO)

  -- Use flowchart for selections
  local prompt = prompts.build_flowchart_prompt(filetype, code_content, "moderate")
  local title = "Selection Diagram\n\nGenerated from visual selection"

  M.call_ai(prompt, output_file, title)
end

-- Generate with provider selection - FIXED VERSION
M.generate_with_provider = function()
  -- Clear screen first
  vim.cmd("redraw")

  local available = providers.get_available_providers()

  if #available == 0 then
    vim.notify("No AI providers available", vim.log.levels.ERROR)
    return
  end

  -- Show menu
  local menu_lines = { "=== Select AI Provider ===", "" }
  for i, name in ipairs(available) do
    local p = providers.providers[name]
    local status = "âœ“"
    table.insert(menu_lines, string.format("[%d] %s %s", i, p.name, status))
  end
  table.insert(menu_lines, "[0] Cancel")
  table.insert(menu_lines, "")

  -- Show in floating window
  local buf = vim.api.nvim_create_buf(false, true)
  vim.api.nvim_buf_set_lines(buf, 0, -1, false, menu_lines)

  local width = 50
  local height = #menu_lines + 2
  local win = vim.api.nvim_open_win(buf, true, {
    relative = "editor",
    width = width,
    height = height,
    col = (vim.o.columns - width) / 2,
    row = (vim.o.lines - height) / 2,
    style = "minimal",
    border = "rounded",
    title = " Select Provider ",
    title_pos = "center",
  })

  -- Set keymaps
  local function close_win()
    if vim.api.nvim_win_is_valid(win) then
      vim.api.nvim_win_close(win, true)
    end
    if vim.api.nvim_buf_is_valid(buf) then
      vim.api.nvim_buf_delete(buf, { force = true })
    end
  end

  for i = 1, #available do
    vim.api.nvim_buf_set_keymap(buf, 'n', tostring(i), '', {
      noremap = true,
      callback = function()
        close_win()
        local selected = available[i]
        vim.notify("Selected: " .. providers.providers[selected].name, vim.log.levels.INFO)

        -- Set provider globally
        providers.set_preferred_provider(selected)

        -- Generate after a short delay
        vim.defer_fn(function()
          M.generate_auto("moderate")
        end, 100)
      end
    })
  end

  vim.api.nvim_buf_set_keymap(buf, 'n', '0', '', {
    noremap = true,
    callback = close_win
  })

  vim.api.nvim_buf_set_keymap(buf, 'n', 'q', '', {
    noremap = true,
    callback = close_win
  })

  vim.api.nvim_buf_set_keymap(buf, 'n', '<Esc>', '', {
    noremap = true,
    callback = close_win
  })
end

-- Set default provider permanently
M.set_provider = function()
  providers.select_provider_async(function(selected)
    if selected then
      providers.set_preferred_provider(selected)
      vim.notify("Default provider set to: " .. providers.providers[selected].name, vim.log.levels.INFO)
    end
  end)
end

-- Regenerate current diagram with new settings
M.regenerate_current = function()
  local current_file = vim.fn.expand('%:p')

  if not current_file:match("_diagram%.md$") and
      not current_file:match("_flowchart%.md$") and
      not current_file:match("_sequence%.md$") and
      not current_file:match("_class_diagram%.md$") and
      not current_file:match("_state_diagram%.md$") and
      not current_file:match("_er_diagram%.md$") and
      not current_file:match("selection_diagram%.md$") then
    vim.notify("Current file is not a generated diagram", vim.log.levels.WARN)
    return
  end

  -- Find source file in header
  local lines = vim.api.nvim_buf_get_lines(0, 0, 10, false)
  local source_file = nil

  for _, line in ipairs(lines) do
    local match = line:match("Generated from:%s*(.+)")
    if match then
      source_file = match
      break
    end
  end

  if not source_file then
    vim.notify("Cannot find source file in diagram header", vim.log.levels.ERROR)
    return
  end

  local dir = vim.fn.expand('%:p:h')
  local source_path = dir .. "/" .. source_file

  if vim.fn.filereadable(source_path) == 0 then
    vim.notify("Source file not found: " .. source_path, vim.log.levels.ERROR)
    return
  end

  -- Read source file
  local source_lines = vim.fn.readfile(source_path)
  local code_content = table.concat(source_lines, "\n")

  -- Detect filetype from extension
  local ext = source_file:match("%.(%w+)$")
  local filetype_map = {
    ts = "typescript",
    tsx = "typescriptreact",
    js = "javascript",
    jsx = "javascriptreact",
    py = "python",
    lua = "lua",
    go = "go",
    rs = "rust",
    java = "java",
    cpp = "cpp",
    c = "c",
    rb = "ruby",
  }
  local filetype = filetype_map[ext] or ext or "text"

  -- Ask regeneration options
  local choice = vim.fn.confirm(
    "Regenerate " .. source_file .. ":",
    "&Auto-detect type\n&Choose diagram type\n&Same type, different complexity\n&Cancel",
    1
  )

  if choice == 4 or choice == 0 then
    return
  end

  if choice == 1 then
    -- Auto-detect
    vim.notify("Regenerating with auto-detection...", vim.log.levels.INFO)
    local analysis = detector.detect_diagram_type(code_content, filetype)
    local recommended = detector.recommend_diagram_type(analysis)

    local prompt = prompts.build_flowchart_prompt(filetype, code_content, "moderate")
    if recommended == "sequence" then
      prompt = prompts.build_sequence_prompt(filetype, code_content)
    elseif recommended == "class_diagram" then
      prompt = prompts.build_class_diagram_prompt(filetype, code_content)
    end

    M.call_ai(prompt, current_file, source_file .. " - Regenerated")
  elseif choice == 2 then
    -- Manual selection - reuse generate_manual logic but with current file
    local type_choice = vim.fn.confirm(
      "Select diagram type:",
      "&Flowchart\n&Sequence\n&Class\nS&tate\n&ER\n&Cancel",
      1
    )

    if type_choice == 6 or type_choice == 0 then return end

    local prompt
    if type_choice == 1 then
      local complexity_choice = vim.fn.confirm("Complexity:", "&Simple\n&Moderate\n&Detailed", 2)
      local complexity = complexity_choice == 1 and "simple" or (complexity_choice == 3 and "detailed" or "moderate")
      prompt = prompts.build_flowchart_prompt(filetype, code_content, complexity)
    elseif type_choice == 2 then
      prompt = prompts.build_sequence_prompt(filetype, code_content)
    elseif type_choice == 3 then
      prompt = prompts.build_class_diagram_prompt(filetype, code_content)
    elseif type_choice == 4 then
      prompt = prompts.build_state_diagram_prompt(filetype, code_content)
    elseif type_choice == 5 then
      prompt = prompts.build_er_diagram_prompt(filetype, code_content)
    end

    M.call_ai(prompt, current_file, source_file .. " - Regenerated")
  elseif choice == 3 then
    -- Same type, different complexity (flowchart only)
    local complexity_choice = vim.fn.confirm(
      "Select complexity:",
      "&Simple (30 nodes)\n&Moderate (50 nodes)\n&Detailed (80 nodes)",
      2
    )

    local complexity = "moderate"
    if complexity_choice == 1 then
      complexity = "simple"
    elseif complexity_choice == 3 then
      complexity = "detailed"
    end

    local prompt = prompts.build_flowchart_prompt(filetype, code_content, complexity)
    M.call_ai(prompt, current_file, source_file .. " - Regenerated (" .. complexity .. ")")
  end
end

-- Preview current diagram
M.preview = function()
  local content = table.concat(vim.api.nvim_buf_get_lines(0, 0, -1, false), "\n")

  if not content:match("```mermaid") then
    vim.notify("No mermaid diagram found in current buffer", vim.log.levels.WARN)
    return
  end

  vim.notify("Opening preview in browser...", vim.log.levels.INFO)
  vim.cmd("MarkdownPreview")
end

return M
