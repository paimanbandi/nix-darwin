-- Main plugin with multi-provider support and automatic fallback
local M = {}
local prompts = require("plugins.markdown-ai-prompts")
local detector = require("plugins.markdown-ai-detector")
local providers = require("plugins.markdown-ai-providers")

-- Validate Mermaid syntax
M.validate_mermaid = function(content)
  local styled_nodes = {}
  for node_id in content:gmatch("style%s+(%w+)%s+fill") do
    styled_nodes[node_id] = true
  end

  local has_issues = false
  for node_id, _ in pairs(styled_nodes) do
    if not content:match(node_id .. "%s*%[") and
        not content:match(node_id .. "%s*%(") and
        not content:match(node_id .. "%s*{") then
      print("Warning: Styled node '" .. node_id .. "' not found")
      has_issues = true
    end
  end

  return not has_issues
end

-- Call AI provider with automatic fallback
M.call_ai = function(prompt, output_file, title)
  vim.notify("Generating diagram (10-30 seconds)...", vim.log.levels.INFO)

  providers.call_provider(prompt, {
    on_success = function(response, provider_name)
      -- Validate response contains mermaid blocks
      if not response:match("```mermaid") then
        vim.notify("Invalid response: No mermaid blocks found", vim.log.levels.ERROR)

        -- Save debug output
        local debug_file = output_file:gsub("%.md$", "_debug.txt")
        local file = io.open(debug_file, "w")
        if file then
          file:write("=== INVALID RESPONSE from " .. provider_name .. " ===\n\n")
          file:write("Expected: ```mermaid ... ```\n")
          file:write("Got:\n\n")
          file:write(response)
          file:close()
          vim.notify("Debug output saved to: " .. debug_file, vim.log.levels.INFO)
        end
        return
      end

      -- Validate mermaid syntax
      if not M.validate_mermaid(response) then
        vim.notify("Warning: Some style definitions may not match nodes", vim.log.levels.WARN)
      end

      -- Create markdown file with metadata
      local md_content = string.format([[# %s

Generated Date: %s
Generated by: %s

%s
]], title, os.date("%Y-%m-%d %H:%M:%S"), providers.providers[provider_name].name, response)

      local file = io.open(output_file, "w")
      if file then
        file:write(md_content)
        file:close()

        vim.notify("Diagram generated successfully with " .. providers.providers[provider_name].name,
          vim.log.levels.INFO)

        vim.schedule(function()
          vim.cmd("edit " .. vim.fn.fnameescape(output_file))
          vim.defer_fn(function()
            vim.cmd("MarkdownPreview")
            vim.notify("Preview opened in browser", vim.log.levels.INFO)
          end, 200)
        end)
      else
        vim.notify("Failed to write output file", vim.log.levels.ERROR)
      end
    end,

    on_error = function(error_msg)
      vim.notify("Generation failed: " .. error_msg, vim.log.levels.ERROR)
      vim.notify("Check provider status with <leader>mi", vim.log.levels.INFO)
    end
  })
end

-- Generate with auto-detection of diagram type
M.generate_auto = function(complexity)
  local filetype = vim.bo.filetype
  local filename = vim.fn.expand('%:t:r')
  local dir = vim.fn.expand('%:p:h')

  local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
  local code_content = table.concat(lines, "\n")

  if #lines > 500 then
    vim.notify("Large file (" .. #lines .. " lines). Generation may take 30-60 seconds", vim.log.levels.WARN)
  end

  -- Auto-detect best diagram type
  vim.notify("Analyzing code...", vim.log.levels.INFO)
  local analysis = detector.detect_diagram_type(code_content, filetype)
  local recommended, scores = detector.recommend_diagram_type(analysis)

  vim.notify("Recommended diagram type: " .. recommended, vim.log.levels.INFO)

  -- Build prompt based on recommendation
  local prompt
  if recommended == "flowchart" then
    prompt = prompts.build_flowchart_prompt(filetype, code_content, complexity or "moderate")
  elseif recommended == "sequence" then
    prompt = prompts.build_sequence_prompt(filetype, code_content)
  elseif recommended == "class_diagram" then
    prompt = prompts.build_class_diagram_prompt(filetype, code_content)
  elseif recommended == "state_diagram" then
    prompt = prompts.build_state_diagram_prompt(filetype, code_content)
  else
    prompt = prompts.build_flowchart_prompt(filetype, code_content, complexity or "moderate")
  end

  local output_file = dir .. "/" .. filename .. "_" .. recommended .. ".md"
  local title = filename .. " - " .. recommended:gsub("_", " "):gsub("^%l", string.upper)

  M.call_ai(prompt, output_file, title)
end

-- Generate with manual diagram type selection
M.generate_manual = function()
  local filetype = vim.bo.filetype
  local filename = vim.fn.expand('%:t:r')
  local dir = vim.fn.expand('%:p:h')

  local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
  local code_content = table.concat(lines, "\n")

  if #lines > 500 then
    vim.notify("Large file (" .. #lines .. " lines). Generation may take longer", vim.log.levels.WARN)
  end

  -- Show diagram type selection menu
  local choice = vim.fn.confirm(
    "Select diagram type:",
    "&Flowchart (Process Flow)\n" ..
    "&Sequence (Time-based Interactions)\n" ..
    "&Class (Object Structure)\n" ..
    "S&tate (State Transitions)\n" ..
    "&ER (Database Schema)\n" ..
    "&Cancel",
    1
  )

  if choice == 6 or choice == 0 then
    return
  end

  local diagram_type
  local prompt

  if choice == 1 then
    diagram_type = "flowchart"

    -- Ask for complexity level
    local complexity_choice = vim.fn.confirm(
      "Select complexity:",
      "&Simple (30 nodes)\n&Moderate (50 nodes)\n&Detailed (80 nodes)",
      2
    )

    local complexity = "moderate"
    if complexity_choice == 1 then
      complexity = "simple"
    elseif complexity_choice == 3 then
      complexity = "detailed"
    end

    prompt = prompts.build_flowchart_prompt(filetype, code_content, complexity)
  elseif choice == 2 then
    diagram_type = "sequence"
    prompt = prompts.build_sequence_prompt(filetype, code_content)
  elseif choice == 3 then
    diagram_type = "class_diagram"
    prompt = prompts.build_class_diagram_prompt(filetype, code_content)
  elseif choice == 4 then
    diagram_type = "state_diagram"
    prompt = prompts.build_state_diagram_prompt(filetype, code_content)
  elseif choice == 5 then
    diagram_type = "er_diagram"
    prompt = prompts.build_er_diagram_prompt(filetype, code_content)
  end

  local output_file = dir .. "/" .. filename .. "_" .. diagram_type .. ".md"
  local title = filename .. " - " .. diagram_type:gsub("_", " "):gsub("^%l", string.upper)

  vim.notify("Generating " .. diagram_type:gsub("_", " ") .. "...", vim.log.levels.INFO)

  M.call_ai(prompt, output_file, title)
end

-- Generate from visual selection
M.generate_from_selection = function()
  local start_pos = vim.fn.getpos("'<")
  local end_pos = vim.fn.getpos("'>")

  if start_pos[2] == 0 or end_pos[2] == 0 then
    vim.notify("No selection found. Use visual mode first", vim.log.levels.WARN)
    return
  end

  local lines = vim.api.nvim_buf_get_lines(0, start_pos[2] - 1, end_pos[2], false)
  local code_content = table.concat(lines, "\n")

  if code_content == "" or code_content:match("^%s*$") then
    vim.notify("Empty selection", vim.log.levels.WARN)
    return
  end

  local filetype = vim.bo.filetype
  local dir = vim.fn.expand('%:p:h')
  local output_file = dir .. "/selection_diagram.md"

  vim.notify("Generating diagram from selection (" .. #lines .. " lines)...", vim.log.levels.INFO)

  -- Use flowchart for selections
  local prompt = prompts.build_flowchart_prompt(filetype, code_content, "moderate")
  local title = "Selection Diagram\n\nGenerated from visual selection"

  M.call_ai(prompt, output_file, title)
end

-- Generate with provider selection
M.generate_with_provider = function()
  local selected_provider = providers.select_provider()

  if not selected_provider then
    vim.notify("No provider selected", vim.log.levels.WARN)
    return
  end

  -- Temporarily set as preferred provider
  local original_provider = providers.get_preferred_provider()
  providers.set_preferred_provider(selected_provider)

  -- Generate with auto-detection
  M.generate_auto("moderate")

  -- Restore original preference
  vim.defer_fn(function()
    providers.set_preferred_provider(original_provider)
  end, 1000)
end

-- Set default provider permanently
M.set_provider = function()
  local selected = providers.select_provider()
  if selected then
    providers.set_preferred_provider(selected)
    vim.notify("Default provider changed. This will be used for future generations", vim.log.levels.INFO)
  end
end

-- Regenerate current diagram with new settings
M.regenerate_current = function()
  local current_file = vim.fn.expand('%:p')

  if not current_file:match("_diagram%.md$") and
      not current_file:match("_flowchart%.md$") and
      not current_file:match("_sequence%.md$") and
      not current_file:match("_class_diagram%.md$") and
      not current_file:match("_state_diagram%.md$") and
      not current_file:match("_er_diagram%.md$") and
      not current_file:match("selection_diagram%.md$") then
    vim.notify("Current file is not a generated diagram", vim.log.levels.WARN)
    return
  end

  -- Find source file in header
  local lines = vim.api.nvim_buf_get_lines(0, 0, 10, false)
  local source_file = nil

  for _, line in ipairs(lines) do
    local match = line:match("Generated from:%s*(.+)")
    if match then
      source_file = match
      break
    end
  end

  if not source_file then
    vim.notify("Cannot find source file in diagram header", vim.log.levels.ERROR)
    return
  end

  local dir = vim.fn.expand('%:p:h')
  local source_path = dir .. "/" .. source_file

  if vim.fn.filereadable(source_path) == 0 then
    vim.notify("Source file not found: " .. source_path, vim.log.levels.ERROR)
    return
  end

  -- Read source file
  local source_lines = vim.fn.readfile(source_path)
  local code_content = table.concat(source_lines, "\n")

  -- Detect filetype from extension
  local ext = source_file:match("%.(%w+)$")
  local filetype_map = {
    ts = "typescript",
    tsx = "typescriptreact",
    js = "javascript",
    jsx = "javascriptreact",
    py = "python",
    lua = "lua",
    go = "go",
    rs = "rust",
    java = "java",
    cpp = "cpp",
    c = "c",
    rb = "ruby",
  }
  local filetype = filetype_map[ext] or ext or "text"

  -- Ask regeneration options
  local choice = vim.fn.confirm(
    "Regenerate " .. source_file .. ":",
    "&Auto-detect type\n&Choose diagram type\n&Same type, different complexity\n&Cancel",
    1
  )

  if choice == 4 or choice == 0 then
    return
  end

  if choice == 1 then
    -- Auto-detect
    vim.notify("Regenerating with auto-detection...", vim.log.levels.INFO)
    local analysis = detector.detect_diagram_type(code_content, filetype)
    local recommended = detector.recommend_diagram_type(analysis)

    local prompt = prompts.build_flowchart_prompt(filetype, code_content, "moderate")
    if recommended == "sequence" then
      prompt = prompts.build_sequence_prompt(filetype, code_content)
    elseif recommended == "class_diagram" then
      prompt = prompts.build_class_diagram_prompt(filetype, code_content)
    end

    M.call_ai(prompt, current_file, source_file .. " - Regenerated")
  elseif choice == 2 then
    -- Manual selection - reuse generate_manual logic but with current file
    local type_choice = vim.fn.confirm(
      "Select diagram type:",
      "&Flowchart\n&Sequence\n&Class\nS&tate\n&ER\n&Cancel",
      1
    )

    if type_choice == 6 or type_choice == 0 then return end

    local prompt
    if type_choice == 1 then
      local complexity_choice = vim.fn.confirm("Complexity:", "&Simple\n&Moderate\n&Detailed", 2)
      local complexity = complexity_choice == 1 and "simple" or (complexity_choice == 3 and "detailed" or "moderate")
      prompt = prompts.build_flowchart_prompt(filetype, code_content, complexity)
    elseif type_choice == 2 then
      prompt = prompts.build_sequence_prompt(filetype, code_content)
    elseif type_choice == 3 then
      prompt = prompts.build_class_diagram_prompt(filetype, code_content)
    elseif type_choice == 4 then
      prompt = prompts.build_state_diagram_prompt(filetype, code_content)
    elseif type_choice == 5 then
      prompt = prompts.build_er_diagram_prompt(filetype, code_content)
    end

    M.call_ai(prompt, current_file, source_file .. " - Regenerated")
  elseif choice == 3 then
    -- Same type, different complexity (flowchart only)
    local complexity_choice = vim.fn.confirm(
      "Select complexity:",
      "&Simple (30 nodes)\n&Moderate (50 nodes)\n&Detailed (80 nodes)",
      2
    )

    local complexity = "moderate"
    if complexity_choice == 1 then
      complexity = "simple"
    elseif complexity_choice == 3 then
      complexity = "detailed"
    end

    local prompt = prompts.build_flowchart_prompt(filetype, code_content, complexity)
    M.call_ai(prompt, current_file, source_file .. " - Regenerated (" .. complexity .. ")")
  end
end

-- Preview current diagram
M.preview = function()
  local content = table.concat(vim.api.nvim_buf_get_lines(0, 0, -1, false), "\n")

  if not content:match("```mermaid") then
    vim.notify("No mermaid diagram found in current buffer", vim.log.levels.WARN)
    return
  end

  vim.notify("Opening preview in browser...", vim.log.levels.INFO)
  vim.cmd("MarkdownPreview")
end

return {
  "iamcco/markdown-preview.nvim",
  keys = {
    {
      "<leader>ma",
      function()
        M.generate_auto("moderate")
      end,
      desc = "Generate Diagram (Auto-detect type)"
    },
    {
      "<leader>mA",
      function()
        M.generate_auto("simple")
      end,
      desc = "Generate Simple Diagram (Auto)"
    },
    {
      "<leader>md",
      function()
        M.generate_manual()
      end,
      desc = "Generate Diagram (Manual type selection)"
    },
    {
      "<leader>mG",
      function()
        M.generate_from_selection()
      end,
      desc = "Generate from Visual Selection",
      mode = "v"
    },
    {
      "<leader>mw",
      function()
        M.generate_with_provider()
      end,
      desc = "Generate with Provider Selection"
    },
    {
      "<leader>mr",
      function()
        M.regenerate_current()
      end,
      desc = "Regenerate Current Diagram"
    },
    {
      "<leader>mS",
      function()
        M.set_provider()
      end,
      desc = "Set Default AI Provider"
    },
    {
      "<leader>mi",
      function()
        providers.show_status()
      end,
      desc = "Show AI Provider Status"
    },
    {
      "<leader>mp",
      function()
        M.preview()
      end,
      desc = "Preview Diagram"
    },
  },
}
