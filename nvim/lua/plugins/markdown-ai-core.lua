-- markdown-ai-core.lua
-- Core diagram generation logic

local M = {}
local config = require("plugins.markdown-ai-config")
local prompts = require("plugins.markdown-ai-prompts")
local detector = require("plugins.markdown-ai-detector")

-- Initialize OpenAI client for DeepSeek/OpenAI
local openai_clients = {}

M.init_openai_client = function(provider_name)
  if openai_clients[provider_name] then
    return openai_clients[provider_name]
  end

  local provider_config = config.get_provider_config(provider_name)
  if not provider_config then
    return nil
  end

  local success, openai_module = pcall(require, "openai")
  if not success then
    vim.notify("OpenAI module not found. Install: pip install openai", vim.log.levels.WARN)
    return nil
  end

  local api_key = os.getenv(provider_config.api_key_env)
  if not api_key then
    vim.notify(provider_config.api_key_env .. " not set", vim.log.levels.ERROR)
    return nil
  end

  local client_config = {
    api_key = api_key,
  }

  if provider_config.base_url then
    client_config.base_url = provider_config.base_url
  end

  openai_clients[provider_name] = openai_module.OpenAI(client_config)
  return openai_clients[provider_name]
end

-- Validate Mermaid syntax
M.validate_mermaid = function(content)
  local styled_nodes = {}
  for node_id in content:gmatch("style%s+(%w+)%s+fill") do
    styled_nodes[node_id] = true
  end

  local has_issues = false
  for node_id, _ in pairs(styled_nodes) do
    if not content:match(node_id .. "%s*%[") and
        not content:match(node_id .. "%s*%(") and
        not content:match(node_id .. "%s*{") then
      print("Warning: Styled node '" .. node_id .. "' not found")
      has_issues = true
    end
  end

  return not has_issues, styled_nodes
end

-- Extract mermaid code from response
M.extract_mermaid_code = function(response_text)
  -- Try multiple patterns to extract mermaid code
  local patterns = {
    "```mermaid\n(.-)\n```",
    "```mermaid\n(.-)```",
    "```mermaid\n(.-)$",
    "```\n(.-)\n```", -- Fallback for no language tag
  }

  for _, pattern in ipairs(patterns) do
    local code = response_text:match(pattern)
    if code and code:match("graph") or code:match("sequenceDiagram") or code:match("classDiagram") then
      -- Clean up the code
      code = code:gsub("^%s+", ""):gsub("%s+$", "")
      return code
    end
  end

  -- If no pattern matched, check if it's already mermaid code
  if response_text:match("graph%s+[TLBR]D") or
      response_text:match("sequenceDiagram") or
      response_text:match("classDiagram") then
    return response_text
  end

  return nil
end

-- Save diagram to file
M.save_diagram_file = function(mermaid_code, output_file, title, provider_name, source_file)
  -- Validate
  local is_valid, _ = M.validate_mermaid(mermaid_code)
  if not is_valid then
    vim.notify("⚠️  Mermaid validation warnings", vim.log.levels.WARN)
  end

  -- Format content
  local md_content = string.format([[# %s

**Generated**: %s
**Source**: %s
**Provider**: %s

```mermaid
<!-- Generated by Neovim Diagram Generator -->
]],
    title,
    os.date("%Y-%m-%d %H:%M:%S"),
    source_file or vim.fn.expand('%:t'),
    provider_name,
    mermaid_code)

  -- Write to file
  local file = io.open(output_file, "w")
  if not file then
    vim.notify("❌ Failed to write file: " .. output_file, vim.log.levels.ERROR)
    return false
  end

  file:write(md_content)
  file:close()

  return true
end

-- Generate output filename
M.generate_output_filename = function(diagram_type, prefix, custom_dir)
  local dir = custom_dir or config.config.save_path or vim.fn.expand('%:p:h')
  local filename = vim.fn.expand('%:t:r')
  local timestamp = os.date("%Y%m%d_%H%M%S")

  -- Create directory if it doesn't exist
  if dir ~= "." then
    vim.fn.mkdir(dir, "p")
  end

  local output_file = string.format("%s/%s_%s_%s.md",
    dir,
    prefix or filename,
    diagram_type,
    timestamp)

  return output_file
end

-- Get diagram title
M.get_diagram_title = function(diagram_type, prefix)
  local base_title = prefix or vim.fn.expand('%:t:r')
  local formatted_type = diagram_type:gsub("_", " "):gsub("^%l", string.upper)

  return base_title .. " - " .. formatted_type
end

-- Build prompt for diagram type
M.build_diagram_prompt = function(diagram_type, filetype, code_content, complexity)
  local complexity_level = complexity or config.config.default_complexity

  if diagram_type == "flowchart" then
    return prompts.build_flowchart_prompt(filetype, code_content, complexity_level)
  elseif diagram_type == "sequence" then
    return prompts.build_sequence_prompt(filetype, code_content)
  elseif diagram_type == "class_diagram" then
    return prompts.build_class_diagram_prompt(filetype, code_content)
  elseif diagram_type == "state_diagram" then
    return prompts.build_state_diagram_prompt(filetype, code_content)
  elseif diagram_type == "er_diagram" then
    return prompts.build_er_diagram_prompt(filetype, code_content)
  elseif diagram_type == "user_journey" then
    return prompts.build_user_journey_prompt(filetype, code_content)
  elseif diagram_type == "gantt" then
    return prompts.build_gantt_prompt(filetype, code_content)
  elseif diagram_type == "pie" then
    return prompts.build_pie_prompt(filetype, code_content)
  elseif diagram_type == "quadrant" then
    return prompts.build_quadrant_prompt(filetype, code_content)
  elseif diagram_type == "requirement" then
    return prompts.build_requirement_prompt(filetype, code_content)
  elseif diagram_type == "gitgraph" then
    return prompts.build_gitgraph_prompt(filetype, code_content)
  elseif diagram_type == "mindmap" then
    return prompts.build_mindmap_prompt(filetype, code_content)
  elseif diagram_type == "timeline" then
    return prompts.build_timeline_prompt(filetype, code_content)
  elseif diagram_type == "sankey" then
    return prompts.build_sankey_prompt(filetype, code_content)
  elseif diagram_type == "xy_chart" then
    return prompts.build_xy_chart_prompt(filetype, code_content)
  elseif diagram_type == "block_diagram" then
    return prompts.build_block_diagram_prompt(filetype, code_content)
  elseif diagram_type == "packet" then
    return prompts.build_packet_prompt(filetype, code_content)
  elseif diagram_type == "kanban" then
    return prompts.build_kanban_prompt(filetype, code_content)
  elseif diagram_type == "architecture" then
    return prompts.build_architecture_prompt(filetype, code_content)
  else
    -- Default to flowchart
    return prompts.build_flowchart_prompt(filetype, code_content, complexity_level)
  end
end

-- Get buffer content
M.get_buffer_content = function()
  local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
  local code_content = table.concat(lines, "\n")

  if code_content == "" then
    vim.notify("⚠️ No content to analyze", vim.log.levels.WARN)
    return nil
  end

  return code_content
end

-- Auto-detect diagram type
M.auto_detect_diagram = function(code_content, filetype)
  if not config.config.auto_detect then
    return "flowchart"
  end

  local analysis = detector.detect_diagram_type(code_content, filetype)
  local recommended, scores = detector.recommend_diagram_type(analysis)

  return recommended, scores
end

return M
